import json
from pathlib import Path

import pulumi
import pulumi_fastly as fastly
from pulumi import Config
from pulumi.invoke import InvokeOptions
from pulumi_aws import route53

from bridge.lib.constants import FASTLY_A_TLS_1_3, FASTLY_CNAME_TLS_1_3
from bridge.lib.magic_numbers import FIVE_MINUTES
from ol_infrastructure.lib.aws.route53_helper import (
    fastly_certificate_validation_records,
    is_root_domain,
    lookup_zone_id_from_domain,
)
from ol_infrastructure.lib.fastly import get_fastly_provider
from ol_infrastructure.lib.pulumi_helper import parse_stack

stack_info = parse_stack()
redirect_config = Config("redirects")
fastly_provider = get_fastly_provider()
# Ensure we always have a ResourceOptions object for opts usage (typing convenience)
fastly_opts = (
    fastly_provider
    if isinstance(fastly_provider, pulumi.ResourceOptions)
    else pulumi.ResourceOptions(provider=fastly_provider)
)
"""Fastly redirector service

Now supports a domain->target mapping provided via Pulumi config.  The previous
configuration accepted a list of domains in `redirects:domains`.  Update your
stack config so that `redirects:domains` is now an object/map whose keys are
source domains and values are fully-qualified target origins (including
scheme).  Paths and query parameters from the original request will be
preserved when performing the redirect.

Backward compatibility: if the value is still a list, we fall back to the old
behaviour (no automatic host redirects) so existing stacks won't break until
their config is updated.
"""

_domains_config = redirect_config.require_object("domains")
redirect_domain_map: dict[str, str]
redirect_domains: list[str]
if isinstance(_domains_config, dict):  # new behaviour
    redirect_domain_map = _domains_config  # {source_host: target_base_url}
    redirect_domains = list(redirect_domain_map.keys())
else:  # legacy list behaviour
    redirect_domain_map = {}
    redirect_domains = list(_domains_config)
ol_redirect_service = fastly.ServiceVcl(
    "ol-redirect-service",
    backends=[
        {
            "address": "ol-redirect-service.s3.us-east-1.amazonaws.com",
            "name": "Empty Bucket for Fastly distribution to work",
            "override_host": "ol-redirect-service.s3.us-east-1.amazonaws.com",
            "port": 443,
            "ssl_cert_hostname": "ol-redirect-service.s3.us-east-1.amazonaws.com",
            "ssl_sni_hostname": "ol-redirect-service.s3.us-east-1.amazonaws.com",
            "use_ssl": True,
        }
    ],
    comment="Managed by Pulumi",
    dictionaries=[
        fastly.ServiceVclDictionaryArgs(name="redirects"),  # path level redirects
        fastly.ServiceVclDictionaryArgs(name="domain_redirects"),  # host -> target
    ],
    domains=[fastly.ServiceVclDomainArgs(name=domain) for domain in redirect_domains],
    headers=[
        {
            "action": "set",
            "destination": "http.Strict-Transport-Security",
            "name": "Generated by force TLS and enable HSTS",
            "source": '"max-age=300"',
            "type": "response",
        }
    ],
    name="ol-redirect-service",
    request_settings=[
        {
            "force_ssl": True,
            "name": "Generated by force TLS and enable HSTS",
            "xff": "",
        }
    ],
    snippets=[
        {
            "content": Path(__file__)
            .parent.joinpath("snippets/recv_redirects.vcl")
            .read_text(),
            "name": "recvRedirects",
            "type": "recv",
        },
        {
            "content": Path(__file__)
            .parent.joinpath("snippets/route_redirects.vcl")
            .read_text(),
            "name": "routeRedirects",
            "type": "error",
        },
    ],
    # fastly_provider is already a ResourceOptions wrapper; add protect flag
    opts=fastly_opts.merge(pulumi.ResourceOptions(protect=True)),
)

if stack_info.env_suffix == "production":
    # Existing path-based redirect dictionary (unchanged semantics)
    redirects_dict_id = ol_redirect_service.dictionaries.apply(
        lambda dicts: str(
            next(d.dictionary_id for d in (dicts or []) if d.name == "redirects")
        )
    )
    ol_redirect_service_redirects_dictionary = fastly.ServiceDictionaryItems(
        "ol-redirect-service-redirects-dictionary",
        dictionary_id=redirects_dict_id,
        items=json.loads(
            Path(__file__).parent.joinpath("ovs_redirect_dict.json").read_text()
        ),
        service_id=ol_redirect_service.id,
        manage_items=True,
        opts=fastly_opts,
    )

# New domain redirect dictionary (created whenever mapping provided)
if redirect_domain_map:
    domain_redirects_dict_id = ol_redirect_service.dictionaries.apply(
        lambda dicts: str(
            next(d.dictionary_id for d in (dicts or []) if d.name == "domain_redirects")
        )
    )
    ol_redirect_service_domain_redirects_dictionary = fastly.ServiceDictionaryItems(
        "ol-redirect-service-domain-redirects-dictionary",
        dictionary_id=domain_redirects_dict_id,
        items=redirect_domain_map,
        service_id=ol_redirect_service.id,
        manage_items=True,
        opts=fastly_opts,
    )

tls_configuration = fastly.get_tls_configuration(
    default=False,
    name="TLS v1.3",
    tls_protocols=["1.2", "1.3"],
    opts=InvokeOptions(provider=fastly_opts.provider),
)

ol_redirect_service_tls = fastly.TlsSubscription(
    "ol-redirect-service-tls-subscription",
    # valid values are certainly, lets-encrypt, or globalsign
    certificate_authority="certainly",
    domains=[
        domain for domain in redirect_domains if lookup_zone_id_from_domain(domain)
    ],
    # Retrieved from 0https://manage.fastly.com/network/tls-configurations
    configuration_id=tls_configuration.id,
    opts=fastly_opts,
)

ol_redirect_service_tls.managed_dns_challenges.apply(
    fastly_certificate_validation_records
)

validated_tls_subscription = fastly.TlsSubscriptionValidation(
    "ol-redirect-service-tls-subscription-validation",
    subscription_id=ol_redirect_service_tls.id,
    opts=fastly_opts,
)

for domain in redirect_domains:
    if zone_id := lookup_zone_id_from_domain(domain):
        record_type = "A" if is_root_domain(domain) else "CNAME"
        record_map = {"A": FASTLY_A_TLS_1_3, "CNAME": [FASTLY_CNAME_TLS_1_3]}
        route53.Record(
            f"fastly-target-for-domain-{domain}",
            name=domain,
            type=record_type,
            records=[
                record.record_value
                for record in tls_configuration.dns_records
                if record.record_type == record_type and record.region == "global"
            ],
            allow_overwrite=True,
            ttl=FIVE_MINUTES,
            zone_id=zone_id,
        )
