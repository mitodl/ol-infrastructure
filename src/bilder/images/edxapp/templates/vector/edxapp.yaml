---
api:
  enabled: true

log_schema:
  timestamp_key: vector_timestamp
  host_key: log_host

sources:
  nginx_access_log:
    type: file
    file_key: log_file
    include:
    - /edx/var/log/nginx/access.log
  nginx_error_log:
    type: file
    file_key: log_file
    include:
    - /edx/var/log/nginx/error.log

  edxapp:
    type: file
    file_key: log_file
    include:
    - /var/log/edxapp/*.log
  auth_log:
    type: file
    file_key: log_file
    include:
    - /var/log/auth.log

  journald_log:
    type: journald
    current_boot_only: true
    include_units:
    - consul
    - consul-template
    - vault

transforms:

  edxapp_labeled_logs:
    inputs:
    - edxapp
    type: remap
    source: |
      event, err = parse_json(.message)
      if event != null {
        . = merge!(., event)
        .@timestamp = .timestamp
        .log_process = "edxapp"
        .environment = "${ENVIRONMENT}"
      }

  auth_log_parser:
    inputs:
    - auth_log
    type: remap
    source: |
      parsed, err = parse_syslog(.message)
      if parsed != null {
        . = merge(., parsed)
        .@timestamp = .timestamp
        del(.timestamp)
        .log_process = "authlog"
        .environment = "${ENVIRONMENT}"
      }

  auth_log_malformed_message_filter:
    inputs:
    - auth_log_parser
    type: filter
    condition: .malformed != true

  auth_log_cron_filter:
    inputs:
    - auth_log_malformed_message_filter
    type: filter
    condition: .appname != "CRON"

  nginx_access_log_parser:
    inputs:
    - nginx_access_log
    type: remap
    source: |
      parsed, err = parse_json(.message)
      if parsed != null {
        .@timestamp = parse_timestamp!(parsed.time, "%FT%T%:z")
        . = merge(., parsed)
        .log_process = "nginx"
        .environment = "${ENVIRONMENT}"
      }

  nginx_access_log_malformed_message_filter:
    inputs:
    - nginx_access_log_parser
    type: filter
    condition: .malformed != true

  nginx_access_log_healthcheck_filter:
    inputs:
    - nginx_access_log_malformed_message_filter
    type: filter
    condition: '! contains!(.http_user_agent, "ELB-HealthChecker")'

  nginx_error_log_parser:
    inputs:
    - nginx_error_log
    type: remap
    source: |
      matches, err = parse_regex(
        .message,
        r'^(?P<time>\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}) \[(?P<log_level>\w+)\] \S+ (?P<message>.*)$'
      )
      if matches != null {
        .message = matches.message
        .@timestamp = parse_timestamp!(matches.time, "%Y/%m/%d %T")
        .log_process = "nginx"
        .environment = "${ENVIRONMENT}"
      } else {
        log(err, level: "error")
        .malformed = true
      }

  nginx_error_log_malformed_message_filter:
    inputs:
    - nginx_error_log_parser
    type: filter
    condition: .malformed != true

  edxapp_enriched_logs:
    type: aws_ec2_metadata
    inputs:
    - edxapp_labeled_logs
    namespace: ec2

sinks:

  elasticsearch_lms_cms:
    inputs:
    - edxapp_enriched_logs
    type: elasticsearch
    endpoint: http://logging-elasticsearch.query.consul:9200
    index: logs-${ENVIRONMENT}-edxapp-%Y.%W
    healthcheck: false

  elasticsearch_authlog:
    inputs:
    - auth_log_cron_filter
    type: elasticsearch
    endpoint: http://logging-elasticsearch.query.consul:9200
    index: logs-${ENVIRONMENT}-authlog-%Y.%W
    healthcheck: false

  grafana_loki_logs:
    inputs:
    - journald_log
    - edxapp_enriched_logs
    - auth_log_cron_filter
    - nginx_error_log_malformed_message_filter
    - nginx_access_log_healthcheck_filter
    type: loki
    auth:
      strategy: basic
      password: ${GRAFANA_CLOUD_API_KEY}
      user: "${GRAFANA_CLOUD_LOKI_API_USER}"
    endpoint: https://logs-prod-us-central1.grafana.net
    encoding:
      codec: json
    labels:
      environment: ${ENVIRONMENT}
      application: edxapp
      service: mitxonline
      hostname: ${HOSTNAME}
    out_of_order_action: rewrite_timestamp
