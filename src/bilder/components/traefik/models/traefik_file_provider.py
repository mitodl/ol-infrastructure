# generated by datamodel-codegen:
#   filename:  https://json.schemastore.org/traefik-v2-file-provider.json
#   timestamp: 2022-10-05T18:43:44+00:00

#   parameters: --snake-case-field --use-subclass-enum --field-include-all-keys --field-constraints --use-schema-description --target-python-version 3.9 --wrap-string-literal --use-default --class-name TraefikFileConfig --use-standard-collections --enum-field-as-literal=one  # noqa: E501

from __future__ import annotations

from typing import Annotated, Any

from pydantic import BaseModel, ConfigDict, Field, RootModel

from bilder.components.traefik.models.traefik_static import (
    ServersTransport,
)


class Certificate(BaseModel):
    cert_file: str | None = Field(None, alias="certFile")
    key_file: str | None = Field(None, alias="keyFile")
    stores: list[str] | None = Field(
        None,
        description=(
            "A list of stores can be specified here to indicate where the certificates"
            " should be stored. Although the stores list will actually be ignored and"
            ' automatically set to ["default"].'
        ),
    )


class ClientAuth(BaseModel):
    """Traefik supports mutual authentication, through the clientAuth section."""

    ca_files: list[str] | None = Field(
        None,
        alias="caFiles",
        description=(
            "For authentication policies that require verification of the client"
            " certificate, the certificate authority for the certificate should be set"
            " here."
        ),
    )
    client_auth_type: str | None = Field(None, alias="clientAuthType")


class Options(BaseModel):
    min_version: str | None = Field(
        None, alias="minVersion", description="Minimum TLS Version"
    )
    max_version: str | None = Field(
        None,
        alias="maxVersion",
        description=(
            "Maximum TLS Version. It is discouraged to use of this setting to disable"
            " TLS1.3. The recommended approach is to update the clients to support"
            " TLS1.3."
        ),
    )
    cipher_suites: list[str] | None = Field(
        None,
        alias="cipherSuites",
        description=(
            "Cipher suites defined for TLS 1.2 and below cannot be used in TLS 1.3, and"
            " vice versa. With TLS 1.3, the cipher suites are not configurable (all"
            " supported cipher suites are safe in this case)."
        ),
    )
    curve_preferences: list[str] | None = Field(
        None,
        alias="curvePreferences",
        description=(
            "This option allows to set the preferred elliptic curves in a specific"
            " order.\n\nThe names of the curves defined by crypto (e.g. CurveP521) and"
            " the RFC defined names (e.g. secp521r1) can be used."
        ),
    )
    sni_strict: bool | None = Field(
        None,
        alias="sniStrict",
        description=(
            "With strict SNI checking enabled, Traefik won't allow connections from"
            " clients that do not specify a server_name extension or don't match any"
            " certificate configured on the tlsOption."
        ),
    )
    prefer_server_cipher_suites: bool | None = Field(
        None,
        alias="preferServerCipherSuites",
        description=(
            "This option allows the server to choose its most preferred cipher suite"
            " instead of the client's. Please note that this is enabled automatically"
            " when minVersion or maxVersion are set."
        ),
    )
    client_auth: ClientAuth | None = Field(
        None,
        alias="clientAuth",
        description=(
            "Traefik supports mutual authentication, through the clientAuth section."
        ),
    )


class DefaultCertificate(BaseModel):
    """
    Traefik can use a default certificate for connections without a SNI, or without a
    matching domain. If no default certificate is provided, Traefik generates and uses
    a self-signed certificate.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    cert_file: str | None = Field(None, alias="certFile")
    key_file: str | None = Field(None, alias="keyFile")


class Domain(BaseModel):
    """Domain is the domain definition for the DefaultCertificate."""

    main: str | None = Field(None, description="Main defines the main domain name.")
    sans: list[str] | None = Field(
        None, description="SANs defines the subject alternative domain names."
    )


class DefaultGeneratedCert(BaseModel):
    """GeneratedCert defines the default generated certificate configuration."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    resolver: str | None = Field(
        None,
        description=(
            "Resolver is the name of the resolver that will be used to issue the"
            " DefaultCertificate."
        ),
    )
    domain: Domain | None = Field(
        None, description="Domain is the domain definition for the DefaultCertificate."
    )


class Stores(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    default_certificate: DefaultCertificate | None = Field(
        None,
        alias="defaultCertificate",
        description=(
            "Traefik can use a default certificate for connections without a SNI, or"
            " without a matching domain. If no default certificate is provided, Traefik"
            " generates and uses a self-signed certificate."
        ),
    )
    default_generated_cert: DefaultGeneratedCert | None = Field(
        None,
        alias="defaultGeneratedCert",
        description=(
            "GeneratedCert defines the default generated certificate configuration."
        ),
    )


class Tls(BaseModel):
    """Configures the TLS connection, TLS options, and certificate stores."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    certificates: list[Certificate] | None = None
    options: dict[str, Options] | None = Field(
        None,
        description=(
            "The TLS options allow one to configure some parameters of the TLS"
            " connection."
        ),
    )
    stores: dict[str, Stores] | None = Field(
        None,
        description=(
            "Any store definition other than the default one (named default) will be"
            " ignored, and there is therefore only one globally available TLS store."
        ),
    )


class Domain1(BaseModel):
    main: str | None = Field(None, description="Main defines the main domain name.")
    sans: list[str] | None = Field(
        None, description="SANs defines the subject alternative domain names."
    )


class Tls1(BaseModel):
    """
    When a TLS section is specified, it instructs Traefik that the current router is
    dedicated to HTTPS requests only (and that the router should ignore HTTP (non TLS)
    requests).  Traefik will terminate the SSL connections (meaning that it will send
    decrypted data to the services).  If you need to define the same route for both HTTP
    and HTTPS requests, you will need to define two different routers: one with the tls
    section, one without.
    """

    options: str | None = Field(
        None,
        description=(
            "The options field enables fine-grained control of the TLS parameters. It"
            " refers to a TLS Options and will be applied only if a Host rule is"
            " defined."
        ),
    )
    cert_resolver: str | None = Field(
        None,
        alias="certResolver",
        description=(
            "If certResolver is defined, Traefik will try to generate certificates"
            " based on routers Host & HostSNI rules."
        ),
    )
    domains: list[Domain1] | None = Field(
        None,
        description=(
            "You can set SANs (alternative domains) for each main domain. Every domain"
            " must have A/AAAA records pointing to Traefik. Each domain & SAN will lead"
            " to a certificate request."
        ),
    )


class HttpRouter(BaseModel):
    """
    A router is in charge of connecting incoming requests to the services that can
    handle them.  In the process, routers may use pieces of middleware to update the
    request, or act before forwarding the request to the service.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    entry_points: list[str] | None = Field(
        None,
        alias="entryPoints",
        description=(
            "If not specified, HTTP routers will accept requests from all defined entry"
            " points. If you want to limit the router scope to a set of entry points,"
            " set the entryPoints option."
        ),
    )
    rule: str = Field(
        ...,
        description=(
            "Rules are a set of matchers configured with values, that determine if a"
            " particular request matches specific criteria. If the rule is verified,"
            " the router becomes active, calls middlewares, and then forwards the"
            " request to the service."
        ),
    )
    priority: int | None = Field(
        0,
        description=(
            "To avoid path overlap, routes are sorted, by default, in descending order"
            " using rules length. The priority is directly equal to the length of the"
            " rule, and so the longest length has the highest priority. A value of 0"
            " for the priority is ignored: priority = 0 means that the default rules"
            " length sorting is used."
        ),
        ge=0,
    )
    middlewares: list[str] | None = Field(
        None,
        description=(
            "You can attach a list of middlewares to each HTTP router. The middlewares"
            " will take effect only if the rule matches, and before forwarding the"
            " request to the service. Middlewares are applied in the same order as"
            " their declaration in router."
        ),
    )
    service: str = Field(
        ...,
        description=(
            "Each request must eventually be handled by a service, which is why each"
            " router definition should include a service target, which is basically"
            " where the request will be passed along to. HTTP routers can only target"
            " HTTP services (not TCP services)."
        ),
    )
    tls: Tls | Tls1 | None = Field(
        None,
        description=(
            "When a TLS section is specified, it instructs Traefik that the current"
            " router is dedicated to HTTPS requests only (and that the router should"
            " ignore HTTP (non TLS) requests). Traefik will terminate the SSL"
            " connections (meaning that it will send decrypted data to the services)."
            " If you need to define the same route for both HTTP and HTTPS requests,"
            " you will need to define two different routers: one with the tls section,"
            " one without."
        ),
    )


class Server(BaseModel):
    url: str = Field(
        ...,
        description=(
            "The url option point to a specific instance. Paths in the servers' url"
            " have no effect. If you want the requests to be sent to a specific path on"
            " your servers, configure your routers to use a corresponding middleware"
            " (e.g. the AddPrefix or ReplacePath) middlewares."
        ),
    )


class Cookie(BaseModel):
    name: str | None = Field(
        None,
        description=(
            "The default cookie name is an abbreviation of a sha1 (ex: _1d52e)."
        ),
    )
    secure: bool | None = False
    http_only: bool | None = Field(default=False, alias="httpOnly")
    same_site: str | None = Field(
        "", alias="sameSite", description="Can be none, lax, strict or empty."
    )


class Sticky(BaseModel):
    """
    When sticky sessions are enabled, a cookie is set on the initial request and
    response to let the client know which server handles the first response.  On
    subsequent requests, to keep the session alive with the same server, the client
    should resend the same cookie.
    """

    cookie: Cookie | None = None


class HealthCheck(BaseModel):
    """
    Configure health check to remove unhealthy servers from the load balancing rotation.
    Traefik will consider your servers healthy as long as they return status codes
    between 2XX and 3XX to the health check requests (carried out every interval).
    Traefik keeps monitoring the health of unhealthy servers.  If a server has recovered
    (returning 2xx -> 3xx responses again), it will be added back to the load balancer
    rotation pool.
    """

    method: str | None = Field(
        None,
        description="If defined, will apply this Method for the health check request.",
    )
    path: str | None = Field(
        None,
        description=(
            "path is appended to the server URL to set the health check endpoint."
        ),
    )
    scheme: str | None = Field(
        None,
        description=(
            "If defined, will replace the server URL scheme for the health check"
            " endpoint"
        ),
    )
    hostname: str | None = Field(
        None,
        description=(
            "If defined, will apply Host header hostname to the health check request."
        ),
    )
    port: int | None = Field(
        None,
        description=(
            "If defined, will replace the server URL port for the health check"
            " endpoint."
        ),
    )
    interval: str | None = Field(
        None,
        description=(
            "Defines the frequency of the health check calls. Interval is to be given"
            " in a format understood by `time.ParseDuration`. The interval must be"
            " greater than the timeout. If configuration doesn't reflect this, the"
            " interval will be set to timeout + 1 second."
        ),
    )
    timeout: str | None = Field(
        None,
        description=(
            "Defines the maximum duration Traefik will wait for a health check request"
            " before considering the server failed (unhealthy). Timeout is to be given"
            " in a format understood by `time.ParseDuration`."
        ),
    )
    headers: dict[str, str] | None = Field(
        None,
        description="Defines custom headers to be sent to the health check endpoint.",
    )
    follow_redirects: bool | None = Field(
        default=True,
        alias="followRedirects",
        description=(
            "Defines whether redirects should be followed during the health check calls"
            " (default: true)."
        ),
    )


class ResponseForwarding(BaseModel):
    """Define how Traefik forwards the response from backend server to the client."""

    flush_interval: str | None = Field(
        None,
        alias="flushInterval",
        description=(
            "Specifies the interval in between flushes to the client while copying the"
            " response body. It is a duration in milliseconds, defaulting to 100. A"
            " negative value means to flush immediately after each write to the client."
            " The flushInterval is ignored when ReverseProxy recognizes a response as a"
            " streaming response; for such responses, writes are flushed to the client"
            " immediately."
        ),
    )


class HttpLoadBalancerService(BaseModel):
    """
    The load balancers are able to load balance the requests between multiple instances
    of your programs.

    Each service has a load-balancer, even if there is only one server to forward
    traffic to.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    servers: list[Server] = Field(
        ...,
        description="Servers declare a single instance of your program.",
        min_length=1,
    )
    sticky: Sticky | None = Field(
        None,
        description=(
            "When sticky sessions are enabled, a cookie is set on the initial request"
            " and response to let the client know which server handles the first"
            " response. On subsequent requests, to keep the session alive with the same"
            " server, the client should resend the same cookie."
        ),
    )
    health_check: HealthCheck | None = Field(
        None,
        alias="healthCheck",
        description=(
            "Configure health check to remove unhealthy servers from the load balancing"
            " rotation. Traefik will consider your servers healthy as long as they"
            " return status codes between 2XX and 3XX to the health check requests"
            " (carried out every interval). Traefik keeps monitoring the health of"
            " unhealthy servers. If a server has recovered (returning 2xx -> 3xx"
            " responses again), it will be added back to the load balancer rotation"
            " pool."
        ),
    )
    pass_host_header: bool | None = Field(
        default=True,
        alias="passHostHeader",
        description=(
            "The passHostHeader allows to forward client Host header to server. By"
            " default, passHostHeader is true."
        ),
    )
    response_forwarding: ResponseForwarding | None = Field(
        None,
        alias="responseForwarding",
        description=(
            "Defines how Traefik forwards the response from the backend server to the"
            " client."
        ),
    )
    servers_transport: str | None = Field(None, alias="serversTransport")


class Service(BaseModel):
    name: str | None = None
    weight: float | None = None


class Cookie1(BaseModel):
    name: str | None = Field(
        None,
        description=(
            "The default cookie name is an abbreviation of a sha1 (ex: _1d52e)."
        ),
    )
    secure: bool | None = False
    http_only: bool | None = Field(default=False, alias="httpOnly")
    same_site: str | None = Field(
        "", alias="sameSite", description="Can be none, lax, strict or empty."
    )


class Sticky1(BaseModel):
    """
    When sticky sessions are enabled, a cookie is set on the initial request and
    response to let the client know which server handles the first response.  On
    subsequent requests, to keep the session alive with the same server, the client
    should resend the same cookie.
    """

    cookie: Cookie1 | None = None


class HttpWeightedService(BaseModel):
    """
    The WRR is able to load balance the requests between multiple services based on
    weights.

    This strategy is only available to load balance between services and not between
    servers.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    services: list[Service] | None = None
    sticky: Sticky1 | None = Field(
        None,
        description=(
            "When sticky sessions are enabled, a cookie is set on the initial request"
            " and response to let the client know which server handles the first"
            " response. On subsequent requests, to keep the session alive with the same"
            " server, the client should resend the same cookie."
        ),
    )
    health_check: dict[str, Any] | None = Field(None, alias="healthCheck")


class Mirror(BaseModel):
    name: str | None = None
    percent: float | None = Field(None, ge=0, le=100.0)


class HttpMirroringService(BaseModel):
    """
    The mirroring is able to mirror requests sent to a service to other services.
    Please note that by default the whole request is buffered in memory while it is
    being mirrored.  See the maxBodySize option for how to modify this behaviour.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    service: str | None = None
    max_body_size: int | None = Field(
        -1,
        alias="maxBodySize",
        description=(
            "maxBodySize is the maximum size allowed for the body of the request. If"
            " the body is larger, the request is not mirrored. Default value is -1,"
            " which means unlimited size."
        ),
    )
    mirrors: list[Mirror] | None = None
    health_check: dict[str, Any] | None = Field(None, alias="healthCheck")


class HttpFailoverService(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    service: str | None = None
    fallback: str | None = None
    health_check: dict[str, Any] | None = Field(None, alias="healthCheck")


class HttpServiceItem(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    load_balancer: HttpLoadBalancerService | None = Field(None, alias="loadBalancer")


class HttpServiceItem1(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    weighted: HttpWeightedService | None = None


class HttpServiceItem2(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    mirroring: HttpMirroringService | None = None


class HttpServiceItem3(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    failover: HttpFailoverService | None = None


class HttpService(
    RootModel[HttpServiceItem | HttpServiceItem1 | HttpServiceItem2 | HttpServiceItem3]
):
    root: HttpServiceItem | HttpServiceItem1 | HttpServiceItem2 | HttpServiceItem3 = (
        Field(
            ...,
            description=(
                "The Services are responsible for configuring how to reach the actual"
                " services that will eventually handle the incoming requests."
            ),
        )
    )


class AddPrefixMiddleware(BaseModel):
    """AddPrefix middleware updates the URL Path of the request before forwarding."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    prefix: str | None = Field(
        None,
        description=(
            "prefix is the string to add before the current path in the requested URL."
            " It should include the leading slash (/)."
        ),
    )


class BasicAuthMiddleware(BaseModel):
    """
    The BasicAuth middleware is a quick way to restrict access to your services to known
    users.  If both users and usersFile are provided, the two are merged.  The contents
    of usersFile have precedence over the values in users.
    """

    users: list[str] | None = Field(
        None,
        description=(
            "The users option is an array of authorized users. Each user will be"
            " declared using the `name:hashed-password` format."
        ),
    )
    users_file: str | None = Field(
        None,
        alias="usersFile",
        description=(
            "The usersFile option is the path to an external file that contains the"
            " authorized users for the middleware.\n\nThe file content is a list of"
            " `name:hashed-password`."
        ),
    )
    realm: str | None = Field(
        "traefik",
        description=(
            "You can customize the realm for the authentication with the realm option."
            " The default value is traefik."
        ),
    )
    header_field: str | None = Field(
        None,
        alias="headerField",
        description=(
            "You can define a header field to store the authenticated user using the"
            " headerField option."
        ),
    )
    remove_header: bool | None = Field(
        default=False,
        alias="removeHeader",
        description=(
            "Set the removeHeader option to true to remove the authorization header"
            " before forwarding the request to your service. (Default value is false.)"
        ),
    )


class BufferingMiddleware(BaseModel):
    """
    The Buffering middleware gives you control on how you want to read the requests
    before sending them to services.

    With Buffering, Traefik reads the entire request into memory (possibly buffering
    large requests into disk), and rejects requests that are over a specified limit.

    This can help services deal with large data (multipart/form-data for example), and
    can minimize time spent sending data to a service.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    max_request_body_bytes: int | None = Field(
        None,
        alias="maxRequestBodyBytes",
        description=(
            "With the maxRequestBodyBytes option, you can configure the maximum allowed"
            " body size for the request (in Bytes).\n\nIf the request exceeds the"
            " allowed size, it is not forwarded to the service and the client gets a"
            " 413 (Request Entity Too Large) response."
        ),
    )
    mem_request_body_bytes: int | None = Field(
        None,
        alias="memRequestBodyBytes",
        description=(
            "You can configure a threshold (in Bytes) from which the request will be"
            " buffered on disk instead of in memory with the memRequestBodyBytes"
            " option."
        ),
    )
    max_response_body_bytes: int | None = Field(
        None,
        alias="maxResponseBodyBytes",
        description=(
            "With the maxResponseBodyBytes option, you can configure the maximum"
            " allowed response size from the service (in Bytes).\n\nIf the response"
            " exceeds the allowed size, it is not forwarded to the client. The client"
            " gets a 413 (Request Entity Too Large) response instead."
        ),
    )
    mem_response_body_bytes: int | None = Field(
        None,
        alias="memResponseBodyBytes",
        description=(
            "You can configure a threshold (in Bytes) from which the response will be"
            " buffered on disk instead of in memory with the memResponseBodyBytes"
            " option."
        ),
    )
    retry_expression: str | None = Field(
        None,
        alias="retryExpression",
        description=(
            "You can have the Buffering middleware replay the request with the help of"
            " the retryExpression option."
        ),
    )


class ChainMiddleware(BaseModel):
    """
    The Chain middleware enables you to define reusable combinations of other pieces of
    middleware.  It makes reusing the same groups easier.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    middlewares: list[str] | None = Field(None, min_length=1)


class CircuitBreakerMiddleware(BaseModel):
    """
    The circuit breaker protects your system from stacking requests to unhealthy
    services (resulting in cascading failures).

    When your system is healthy, the circuit is closed (normal operations).  When your
    system becomes unhealthy, the circuit becomes open and the requests are no longer
    forwarded (but handled by a fallback mechanism).

    To assess if your system is healthy, the circuit breaker constantly monitors the
    services.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    expression: str | None = Field(
        None,
        description=(
            "You can specify an expression that, once matched, will trigger the circuit"
            " breaker (and apply the fallback mechanism instead of calling your"
            " services)."
        ),
    )
    check_period: str | None = Field(
        None,
        alias="checkPeriod",
        description=(
            "The interval between successive checks of the circuit breaker condition"
            " (when in standby state)"
        ),
    )
    fallback_duration: str | None = Field(
        None,
        alias="fallbackDuration",
        description=(
            "The duration for which the circuit breaker will wait before trying to"
            " recover (from a tripped state)."
        ),
    )
    recovery_duration: str | None = Field(
        None,
        alias="recoveryDuration",
        description=(
            "The duration for which the circuit breaker will try to recover (as soon as"
            " it is in recovering state)."
        ),
    )


class CompressMiddleware(BaseModel):
    """The Compress middleware enables the gzip compression."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    excluded_content_types: list[str] | None = Field(
        None,
        alias="excludedContentTypes",
        description=(
            "excludedContentTypes specifies a list of content types to compare the"
            " Content-Type header of the incoming requests to before"
            " compressing.\n\nThe requests with content types defined in"
            " excludedContentTypes are not compressed.\n\nContent types are compared in"
            " a case-insensitive, whitespace-ignored manner."
        ),
    )
    min_response_body_bytes: int | None = Field(
        None,
        alias="minResponseBodyBytes",
        description=(
            "specifies the minimum amount of bytes a response body must have to be"
            " compressed."
        ),
    )


class ContentTypeMiddleware(BaseModel):
    """
    The Content-Type middleware - or rather its unique autoDetect option - specifies
    whether to let the Content-Type header, if it has not been set by the backend, be
    automatically set to a value derived from the contents of the response.

    As a proxy, the default behavior should be to leave the header alone, regardless of
    what the backend did with it.  However, the historic default was to always
    auto-detect and set the header if it was nil, and it is going to be kept that way in
    order to support users currently relying on it.  This middleware exists to enable
    the correct behavior until at least the default one can be changed in a future
    version.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    auto_detect: bool | None = Field(
        default=False,
        alias="autoDetect",
        description=(
            "autoDetect specifies whether to let the Content-Type header, if it has not"
            " been set by the backend, be automatically set to a value derived from the"
            " contents of the response."
        ),
    )


class DigestAuthMiddleware(BaseModel):
    """
    The DigestAuth middleware is a quick way to restrict access to your services to
    known users.  If both users and usersFile are provided, the two are merged.  The
    contents of usersFile have precedence over the values in users.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    users: list[str] | None = Field(
        None,
        description=(
            "The users option is an array of authorized users. Each user will be"
            " declared using the `name:realm:encoded-password` format."
        ),
    )
    users_file: str | None = Field(
        None,
        alias="usersFile",
        description=(
            "The usersFile option is the path to an external file that contains the"
            " authorized users for the middleware.\n\nThe file content is a list of"
            " `name:realm:encoded-password`."
        ),
    )
    realm: str | None = Field(
        "traefik",
        description=(
            "You can customize the realm for the authentication with the realm option."
            " The default value is traefik."
        ),
    )
    header_field: str | None = Field(
        None,
        alias="headerField",
        description=(
            "You can customize the header field for the authenticated user using the"
            " headerField option."
        ),
    )
    remove_header: bool | None = Field(
        default=False,
        alias="removeHeader",
        description=(
            "Set the removeHeader option to true to remove the authorization header"
            " before forwarding the request to your service. (Default value is false.)"
        ),
    )


class ErrorsMiddleware(BaseModel):
    """
    The ErrorPage middleware returns a custom page in lieu of the default, according to
    configured ranges of HTTP Status codes.  The error page itself is not hosted by
    Traefik.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    status: list[str] | None = Field(
        None,
        description=(
            "The status that will trigger the error page.\n\nThe status code ranges are"
            " inclusive (500-599 will trigger with every code between 500 and 599, 500"
            " and 599 included). You can define either a status code like 500 or ranges"
            " with a syntax like 500-599."
        ),
    )
    service: str | None = Field(
        None, description="The service that will serve the new requested error page."
    )
    query: str | None = Field(
        None,
        description=(
            "The URL for the error page (hosted by service). You can use {status} in"
            " the query, that will be replaced by the received status code."
        ),
    )


class Tls2(BaseModel):
    """The TLS configuration from Traefik to the authentication server."""

    ca: str | None = Field(
        None,
        description=(
            "Certificate Authority used for the secured connection to the"
            " authentication server."
        ),
    )
    ca_optional: bool | None = Field(
        None,
        alias="caOptional",
        description=(
            "Policy used for the secured connection with TLS Client Authentication to"
            " the authentication server. Requires tls.ca to be defined."
        ),
    )
    cert: str | None = Field(
        None,
        description=(
            "Public certificate used for the secured connection to the authentication"
            " server."
        ),
    )
    key: str | None = Field(
        None,
        description=(
            "Private certificate used for the secure connection to the authentication"
            " server."
        ),
    )
    insecure_skip_verify: bool | None = Field(
        None,
        alias="insecureSkipVerify",
        description=(
            "If insecureSkipVerify is true, TLS for the connection to authentication"
            " server accepts any certificate presented by the server and any host name"
            " in that certificate."
        ),
    )


class ForwardAuthMiddleware(BaseModel):
    """
    The ForwardAuth middleware delegate the authentication to an external service.  If
    the service response code is 2XX, access is granted and the original request is
    performed.  Otherwise, the response from the authentication server is returned.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    address: str | None = Field(
        None,
        description="The address option defines the authentication server address.",
    )
    tls: Annotated[
        Tls2 | None,
        Field(
            dependencies={"caOptional": ["ca"]},
            description=(
                "The tls option is the TLS configuration from Traefik to the "
                "authentication server."
            ),
        ),
    ] = None
    trust_forward_header: bool | None = Field(
        None,
        alias="trustForwardHeader",
        description=(
            "Set the trustForwardHeader option to true to trust all the existing"
            " X-Forwarded-* headers."
        ),
    )
    auth_response_headers: list[str] | None = Field(
        None,
        alias="authResponseHeaders",
        description=(
            "The authResponseHeaders option is the list of the headers to copy from the"
            " authentication server to the request."
        ),
    )
    auth_response_headers_regex: str | None = Field(
        None,
        alias="authResponseHeadersRegex",
        description=(
            "The authResponseHeadersRegex option is the regex to match headers to copy"
            " from the authentication server response and set on forwarded request,"
            " after stripping all headers that match the regex."
        ),
    )
    auth_request_headers: list[str] | None = Field(
        None,
        alias="authRequestHeaders",
        description=(
            "The authRequestHeaders option is the list of the headers to copy from the"
            " request to the authentication server."
        ),
    )


class HeadersMiddleware(BaseModel):
    """The Headers middleware can manage the requests/responses headers."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    custom_request_headers: dict[str, str] | None = Field(
        None,
        alias="customRequestHeaders",
        description=(
            "The customRequestHeaders option lists the Header names and values to apply"
            " to the request."
        ),
    )
    custom_response_headers: dict[str, str] | None = Field(
        None,
        alias="customResponseHeaders",
        description=(
            "The customResponseHeaders option lists the Header names and values to"
            " apply to the response."
        ),
    )
    access_control_allow_credentials: bool | None = Field(
        None,
        alias="accessControlAllowCredentials",
        description=(
            "The accessControlAllowCredentials indicates whether the request can"
            " include user credentials."
        ),
    )
    access_control_allow_headers: list[str] | None = Field(
        None,
        alias="accessControlAllowHeaders",
        description=(
            "The accessControlAllowHeaders indicates which header field names can be"
            " used as part of the request."
        ),
    )
    access_control_allow_methods: list[str] | None = Field(
        None,
        alias="accessControlAllowMethods",
        description=(
            "The accessControlAllowMethods indicates which methods can be used during"
            " requests."
        ),
    )
    access_control_allow_origin_list: list[str] | None = Field(
        None,
        alias="accessControlAllowOriginList",
        description=(
            "The accessControlAllowOriginList indicates whether a resource can be"
            " shared by returning different values.\n\nA wildcard origin * can also be"
            " configured, and will match all requests. If this value is set by a"
            " backend server, it will be overwritten by Traefik\n\nThis value can"
            " contain a list of allowed origins."
        ),
    )
    access_control_allow_origin_list_regex: list[str] | None = Field(
        None,
        alias="accessControlAllowOriginListRegex",
        description=(
            "The accessControlAllowOriginListRegex option is the counterpart of the"
            " accessControlAllowOriginList option with regular expressions instead of"
            " origin values."
        ),
    )
    access_control_expose_headers: list[str] | None = Field(
        None,
        alias="accessControlExposeHeaders",
        description=(
            "The accessControlExposeHeaders indicates which headers are safe to expose"
            " to the api of a CORS API specification."
        ),
    )
    access_control_max_age: int | None = Field(
        None,
        alias="accessControlMaxAge",
        description=(
            "The accessControlMaxAge indicates how long (in seconds) a preflight"
            " request can be cached."
        ),
    )
    add_vary_header: bool | None = Field(
        None,
        alias="addVaryHeader",
        description=(
            "The addVaryHeader is used in conjunction with accessControlAllowOriginList"
            " to determine whether the vary header should be added or modified to"
            " demonstrate that server responses can differ based on the value of the"
            " origin header."
        ),
    )
    allowed_hosts: list[str] | None = Field(
        None,
        alias="allowedHosts",
        description=(
            "The allowedHosts option lists fully qualified domain names that are"
            " allowed."
        ),
    )
    hosts_proxy_headers: list[str] | None = Field(
        None,
        alias="hostsProxyHeaders",
        description=(
            "The hostsProxyHeaders option is a set of header keys that may hold a"
            " proxied hostname value for the request."
        ),
    )
    ssl_redirect: bool | None = Field(
        None,
        alias="sslRedirect",
        description="The sslRedirect is set to true, then only allow https requests.",
    )
    ssl_temporary_redirect: bool | None = Field(
        None,
        alias="sslTemporaryRedirect",
        description=(
            "Set the sslTemporaryRedirect to true to force an SSL redirection using a"
            " 302 (instead of a 301)."
        ),
    )
    ssl_host: str | None = Field(
        None,
        alias="sslHost",
        description=(
            "The sslHost option is the host name that is used to redirect http requests"
            " to https."
        ),
    )
    ssl_proxy_headers: dict[str, str] | None = Field(
        None,
        alias="sslProxyHeaders",
        description=(
            "The sslProxyHeaders option is set of header keys with associated values"
            " that would indicate a valid https request. Useful when using other"
            ' proxies with header like: "X-Forwarded-Proto": "https".'
        ),
    )
    ssl_force_host: bool | None = Field(
        None,
        alias="sslForceHost",
        description=(
            "Set sslForceHost to true and set SSLHost to forced requests to use SSLHost"
            " even the ones that are already using SSL."
        ),
    )
    sts_seconds: int | None = Field(
        None,
        alias="stsSeconds",
        description=(
            "The stsSeconds is the max-age of the Strict-Transport-Security header. If"
            " set to 0, would NOT include the header."
        ),
    )
    sts_include_subdomains: bool | None = Field(
        None,
        alias="stsIncludeSubdomains",
        description=(
            "The stsIncludeSubdomains is set to true, the includeSubDomains directive"
            " will be appended to the Strict-Transport-Security header."
        ),
    )
    sts_preload: bool | None = Field(
        None,
        alias="stsPreload",
        description=(
            "Set stsPreload to true to have the preload flag appended to the"
            " Strict-Transport-Security header."
        ),
    )
    force_sts_header: bool | None = Field(
        None,
        alias="forceSTSHeader",
        description=(
            "Set forceSTSHeader to true, to add the STS header even when the connection"
            " is HTTP."
        ),
    )
    frame_deny: bool | None = Field(
        None,
        alias="frameDeny",
        description=(
            "Set frameDeny to true to add the X-Frame-Options header with the value of"
            " DENY."
        ),
    )
    custom_frame_options_value: str | None = Field(
        None,
        alias="customFrameOptionsValue",
        description=(
            "The customFrameOptionsValue allows the X-Frame-Options header value to be"
            " set with a custom value. This overrides the FrameDeny option."
        ),
    )
    content_type_nosniff: bool | None = Field(
        None,
        alias="contentTypeNosniff",
        description=(
            "Set contentTypeNosniff to true to add the X-Content-Type-Options header"
            " with the value nosniff."
        ),
    )
    browser_xss_filter: bool | None = Field(
        None,
        alias="browserXssFilter",
        description=(
            "Set browserXssFilter to true to add the X-XSS-Protection header with the"
            " value 1; mode=block."
        ),
    )
    custom_browser_xss_value: str | None = Field(
        None,
        alias="customBrowserXSSValue",
        description=(
            "The customBrowserXssValue option allows the X-XSS-Protection header value"
            " to be set with a custom value. This overrides the BrowserXssFilter"
            " option."
        ),
    )
    content_security_policy: str | None = Field(
        None,
        alias="contentSecurityPolicy",
        description=(
            "The contentSecurityPolicy option allows the Content-Security-Policy header"
            " value to be set with a custom value."
        ),
    )
    public_key: str | None = Field(
        None,
        alias="publicKey",
        description=(
            "The publicKey implements HPKP to prevent MITM attacks with forged"
            " certificates."
        ),
    )
    referrer_policy: str | None = Field(
        None,
        alias="referrerPolicy",
        description=(
            "The referrerPolicy allows sites to control when browsers will pass the"
            " Referer header to other sites."
        ),
    )
    feature_policy: str | None = Field(
        None,
        alias="featurePolicy",
        description="The featurePolicy allows sites to control browser features.",
    )
    permissions_policy: str | None = Field(
        None,
        alias="permissionsPolicy",
        description="The permissionsPolicy allows sites to control browser features.",
    )
    is_development: bool | None = Field(
        None,
        alias="isDevelopment",
        description=(
            "Set isDevelopment to true when developing. The AllowedHosts, SSL, and STS"
            " options can cause some unwanted effects. Usually testing happens on http,"
            " not https, and on localhost, not your production domain.\nIf you would"
            " like your development environment to mimic production with complete Host"
            " blocking, SSL redirects, and STS headers, leave this as false."
        ),
    )


class IpStrategy(BaseModel):
    """Defines parameters that set how Traefik will determine the client IP."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    depth: int | None = Field(
        None,
        description=(
            "The depth option tells Traefik to use the X-Forwarded-For header and take"
            " the IP located at the depth position (starting from the right). If depth"
            " is greater than the total number of IPs in X-Forwarded-For, then the"
            " client IP will be empty. depth is ignored if its value is lesser than or"
            " equal to 0."
        ),
    )
    excluded_i_ps: list[str] | None = Field(
        None,
        alias="excludedIPs",
        description=(
            "excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the"
            " first IP not in the list. If depth is specified, excludedIPs is ignored."
        ),
    )


class IpWhiteListMiddleware(BaseModel):
    """IPWhitelist accepts / refuses requests based on the client IP."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    source_range: list[str] | None = Field(
        None,
        alias="sourceRange",
        description=(
            "The sourceRange option sets the allowed IPs (or ranges of allowed IPs by"
            " using CIDR notation)."
        ),
    )
    ip_strategy: IpStrategy | None = Field(None, alias="ipStrategy")


class SourceCriterion(BaseModel):
    """
    SourceCriterion defines what criterion is used to group requests as originating from
    a common source.  The precedence order is ipStrategy, then requestHeaderName, then
    requestHost.  If none are set, the default is to use the requestHost.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    ip_strategy: IpStrategy | None = Field(None, alias="ipStrategy")
    request_header_name: str | None = Field(
        None,
        alias="requestHeaderName",
        description=(
            "Requests having the same value for the given header are grouped as coming"
            " from the same source."
        ),
    )
    request_host: bool | None = Field(
        None,
        alias="requestHost",
        description="Whether to consider the request host as the source.",
    )


class InFlightReqMiddleware(BaseModel):
    """
    To proactively prevent services from being overwhelmed with high load, a limit on
    the number of simultaneous in-flight requests can be applied.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    amount: int | None = Field(
        None,
        description=(
            "The amount option defines the maximum amount of allowed simultaneous"
            " in-flight request. The middleware will return an HTTP 429 Too Many"
            " Requests if there are already amount requests in progress (based on the"
            " same sourceCriterion strategy)."
        ),
    )
    source_criterion: SourceCriterion | None = Field(None, alias="sourceCriterion")


class Subject(BaseModel):
    """
    The subject select the specific client certificate subject details you want to add
    to the X-Forwarded-Tls-Client-Cert-Info header.
    """

    country: bool | None = Field(
        None,
        description=(
            "Set the country option to true to add the country information into the"
            " subject."
        ),
    )
    province: bool | None = Field(
        None,
        description=(
            "Set the province option to true to add the province information into the"
            " subject."
        ),
    )
    locality: bool | None = Field(
        None,
        description=(
            "Set the locality option to true to add the locality information into the"
            " subject."
        ),
    )
    organization: bool | None = Field(
        None,
        description=(
            "Set the organization option to true to add the organization information"
            " into the subject."
        ),
    )
    common_name: bool | None = Field(
        None,
        alias="commonName",
        description=(
            "Set the commonName option to true to add the commonName information into"
            " the subject."
        ),
    )
    serial_number: bool | None = Field(
        None,
        alias="serialNumber",
        description=(
            "Set the serialNumber option to true to add the serialNumber information"
            " into the subject."
        ),
    )
    domain_component: bool | None = Field(
        None,
        alias="domainComponent",
        description=(
            "Set the domainComponent option to true to add the domainComponent"
            " information into the subject."
        ),
    )


class Issuer(BaseModel):
    """
    The issuer select the specific client certificate issuer details you want to add to
    the X-Forwarded-Tls-Client-Cert-Info header.
    """

    country: bool | None = Field(
        None,
        description=(
            "Set the country option to true to add the country information into the"
            " issuer."
        ),
    )
    province: bool | None = Field(
        None,
        description=(
            "Set the province option to true to add the province information into the"
            " issuer."
        ),
    )
    locality: bool | None = Field(
        None,
        description=(
            "Set the locality option to true to add the locality information into the"
            " issuer."
        ),
    )
    organization: bool | None = Field(
        None,
        description=(
            "Set the organization option to true to add the organization information"
            " into the issuer."
        ),
    )
    common_name: bool | None = Field(
        None,
        alias="commonName",
        description=(
            "Set the commonName option to true to add the commonName information into"
            " the issuer."
        ),
    )
    serial_number: bool | None = Field(
        None,
        alias="serialNumber",
        description=(
            "Set the serialNumber option to true to add the serialNumber information"
            " into the issuer."
        ),
    )
    domain_component: bool | None = Field(
        None,
        alias="domainComponent",
        description=(
            "Set the domainComponent option to true to add the domainComponent"
            " information into the issuer."
        ),
    )


class Info(BaseModel):
    """
    The info option select the specific client certificate details you want to add to
    the X-Forwarded-Tls-Client-Cert-Info header.  The value of the header will be an
    escaped concatenation of all the selected certificate details.
    """

    not_after: bool | None = Field(
        None,
        alias="notAfter",
        description=(
            "Set the notAfter option to true to add the Not After information from the"
            " Validity part."
        ),
    )
    not_before: bool | None = Field(
        None,
        alias="notBefore",
        description=(
            "Set the notBefore option to true to add the Not Before information from"
            " the Validity part."
        ),
    )
    sans: bool | None = Field(
        None,
        description=(
            "Set the sans option to true to add the Subject Alternative Name"
            " information from the Subject Alternative Name part."
        ),
    )
    subject: Subject | None = Field(
        None,
        description=(
            "The subject select the specific client certificate subject details you"
            " want to add to the X-Forwarded-Tls-Client-Cert-Info header."
        ),
    )
    issuer: Issuer | None = Field(
        None,
        description=(
            "The issuer select the specific client certificate issuer details you want"
            " to add to the X-Forwarded-Tls-Client-Cert-Info header."
        ),
    )


class PassTLSClientCertMiddleware(BaseModel):
    """Adds in header the selected data from the passed client tls certificate."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    pem: bool | None = Field(
        None,
        description=(
            "The pem option sets the X-Forwarded-Tls-Client-Cert header with the escape"
            " certificate."
        ),
    )
    info: Info | None = Field(
        None,
        description=(
            "The info option select the specific client certificate details you want to"
            " add to the X-Forwarded-Tls-Client-Cert-Info header. The value of the"
            " header will be an escaped concatenation of all the selected certificate"
            " details."
        ),
    )


class PluginMiddleware(BaseModel):
    """Some plugins will need to be configured by adding a dynamic configuration."""

    model_config = ConfigDict(populate_by_name=True, extra="allow")


class RateLimitMiddleware(BaseModel):
    """
    The RateLimit middleware ensures that services will receive a fair number of
    requests, and allows one to define what fair is.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    average: str | float | None = Field(
        None,
        description=(
            "average is the maximum rate, by default in requests by second, allowed for"
            " the given source.\n\nIt defaults to 0, which means no rate"
            " limiting.\n\nThe rate is actually defined by dividing average by period."
            " So for a rate below 1 req/s, one needs to define a period larger than a"
            " second."
        ),
    )
    period: str | float | None = Field(
        None,
        description=(
            "period, in combination with average, defines the actual maximum"
            " rate.\n\nIt defaults to 1 second."
        ),
    )
    burst: float | None = Field(
        1,
        description=(
            "burst is the maximum number of requests allowed to go through in the same"
            " arbitrarily small period of time.\n\nIt defaults to 1."
        ),
    )
    source_criterion: SourceCriterion | None = Field(None, alias="sourceCriterion")


class RedirectRegexMiddleware(BaseModel):
    """Redirect a request from an url to another with regex matching and replacement."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    permanent: bool | None = Field(
        None,
        description=(
            "Set the permanent option to true to apply a permanent redirection."
        ),
    )
    regex: str | None = Field(
        None,
        description=(
            "The regex option is the regular expression to match and capture elements"
            " from the request URL."
        ),
    )
    replacement: str | None = Field(
        None,
        description=(
            "The replacement option defines how to modify the URL to have the new"
            " target URL. Care should be taken when defining replacement expand"
            " variables: $1x is equivalent to ${1x}, not ${1}x (see Regexp.Expand), so"
            " use ${1} syntax."
        ),
    )


class RedirectSchemeMiddleware(BaseModel):
    """RedirectScheme redirect request from a scheme to another."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    permanent: bool | None = Field(
        None,
        description=(
            "Set the permanent option to true to apply a permanent redirection."
        ),
    )
    scheme: str | None = Field(
        None, description="The scheme option defines the scheme of the new url."
    )
    port: str | None = Field(
        None,
        description=(
            "The port option defines the port of the new url. Port in this"
            " configuration is a string, not a numeric value."
        ),
    )


class ReplacePathMiddleware(BaseModel):
    """
    Replace the path of the request url.  It will replace the actual path by the
    specified one and will store the original path in a X-Replaced-Path header.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    path: str | None = Field(
        None,
        description=(
            "The path option defines the path to use as replacement in the request url."
        ),
    )


class ReplacePathRegexMiddleware(BaseModel):
    """
    The ReplaceRegex replace a path from an url to another with regex matching and
    replacement.  It will replace the actual path by the specified one and store the
    original path in a X-Replaced-Path header.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    regex: str | None = Field(
        None,
        description=(
            "The regex option is the regular expression to match and capture the path"
            " from the request URL."
        ),
    )
    replacement: str | None = Field(
        None,
        description=(
            "The replacement option defines how to modify the path to have the new"
            " target path. Care should be taken when defining replacement expand"
            " variables: $1x is equivalent to ${1x}, not ${1}x (see Regexp.Expand), so"
            " use ${1} syntax."
        ),
    )


class RetryMiddleware(BaseModel):
    """
    The Retry middleware is in charge of reissuing a request a given number of times to
    a backend server if that server does not reply.  To be clear, as soon as the server
    answers, the middleware stops retrying, regardless of the response status.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    attempts: int = Field(
        ...,
        description=(
            "The attempts option defines how many times the request should be retried."
        ),
    )
    initial_interval: str | None = Field(
        None,
        alias="initialInterval",
        description=(
            "The initialInterval option defines the first wait time in the exponential"
            " backoff series."
        ),
    )


class StripPrefixMiddleware(BaseModel):
    """
    Remove the specified prefixes from the URL path.  It will strip the matching path
    prefix and will store the matching path prefix in a X-Forwarded-Prefix header.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    prefixes: list[str] | None = Field(
        None,
        description=(
            "The prefixes option defines the prefixes to strip from the request URL"
        ),
    )
    force_slash: bool | None = Field(
        None,
        alias="forceSlash",
        description=(
            "The forceSlash option makes sure that the resulting stripped path is not"
            " the empty string, by replacing it with / when necessary.\n\nThis option"
            " was added to keep the initial (non-intuitive) behavior of this"
            " middleware, in order to avoid introducing a breaking change.\n\nIt's"
            " recommended to explicitly set forceSlash to false."
        ),
    )


class StripPrefixRegexMiddleware(BaseModel):
    """
    Remove the matching prefixes from the URL path.  It will strip the matching path
    prefix and will store the matching path prefix in a X-Forwarded-Prefix header.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    regex: list[str] | None = Field(
        None,
        description=(
            "The regex option is the regular expression to match the path prefix from"
            " the request URL."
        ),
    )


class HttpMiddlewareItem(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    add_prefix: AddPrefixMiddleware | None = Field(None, alias="addPrefix")


class HttpMiddlewareItem1(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    basic_auth: BasicAuthMiddleware | None = Field(None, alias="basicAuth")


class HttpMiddlewareItem2(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    buffering: BufferingMiddleware | None = None


class HttpMiddlewareItem3(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    chain: ChainMiddleware | None = None


class HttpMiddlewareItem4(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    circuit_breaker: CircuitBreakerMiddleware | None = Field(
        None, alias="circuitBreaker"
    )


class HttpMiddlewareItem5(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    compress: CompressMiddleware | None = None


class HttpMiddlewareItem6(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    content_type: ContentTypeMiddleware | None = Field(None, alias="contentType")


class HttpMiddlewareItem7(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    digest_auth: DigestAuthMiddleware | None = Field(None, alias="digestAuth")


class HttpMiddlewareItem8(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    errors: ErrorsMiddleware | None = None


class HttpMiddlewareItem9(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    forward_auth: ForwardAuthMiddleware | None = Field(None, alias="forwardAuth")


class HttpMiddlewareItem10(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    headers: HeadersMiddleware | None = None


class HttpMiddlewareItem11(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    ip_white_list: IpWhiteListMiddleware | None = Field(None, alias="ipWhiteList")


class HttpMiddlewareItem12(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    in_flight_req: InFlightReqMiddleware | None = Field(None, alias="inFlightReq")


class HttpMiddlewareItem13(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    pass_tls_client_cert: PassTLSClientCertMiddleware | None = Field(
        None, alias="passTLSClientCert"
    )


class HttpMiddlewareItem14(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    plugin: PluginMiddleware | None = None


class HttpMiddlewareItem15(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    rate_limit: RateLimitMiddleware | None = Field(None, alias="rateLimit")


class HttpMiddlewareItem16(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    redirect_regex: RedirectRegexMiddleware | None = Field(None, alias="redirectRegex")


class HttpMiddlewareItem17(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    redirect_scheme: RedirectSchemeMiddleware | None = Field(
        None, alias="redirectScheme"
    )


class HttpMiddlewareItem18(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    replace_path: ReplacePathMiddleware | None = Field(None, alias="replacePath")


class HttpMiddlewareItem19(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    replace_path_regex: ReplacePathRegexMiddleware | None = Field(
        None, alias="replacePathRegex"
    )


class HttpMiddlewareItem20(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    retry: RetryMiddleware | None = None


class HttpMiddlewareItem21(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    strip_prefix: StripPrefixMiddleware | None = Field(None, alias="stripPrefix")


class HttpMiddlewareItem22(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    strip_prefix_regex: StripPrefixRegexMiddleware | None = Field(
        None, alias="stripPrefixRegex"
    )


HttpMiddleware = RootModel[
    HttpMiddlewareItem
    | HttpMiddlewareItem1
    | HttpMiddlewareItem2
    | HttpMiddlewareItem3
    | HttpMiddlewareItem4
    | HttpMiddlewareItem5
    | HttpMiddlewareItem6
    | HttpMiddlewareItem7
    | HttpMiddlewareItem8
    | HttpMiddlewareItem9
    | HttpMiddlewareItem10
    | HttpMiddlewareItem11
    | HttpMiddlewareItem12
    | HttpMiddlewareItem13
    | HttpMiddlewareItem14
    | HttpMiddlewareItem15
    | HttpMiddlewareItem16
    | HttpMiddlewareItem17
    | HttpMiddlewareItem18
    | HttpMiddlewareItem19
    | HttpMiddlewareItem20
    | HttpMiddlewareItem21
    | HttpMiddlewareItem22
]


class Domain2(BaseModel):
    main: str | None = Field(None, description="Main defines the main domain name.")
    sans: list[str] | None = Field(
        None, description="SANs defines the subject alternative domain names."
    )


class Tls3(BaseModel):
    """
    When a TLS section is specified, it instructs Traefik that the current router is
    dedicated to TLS requests only (and that the router should ignore non-TLS requests).

    By default, a router with a TLS section will terminate the TLS connections, meaning
    that it will send decrypted data to the services.
    """

    passthrough: bool | None = Field(
        default=False,
        description=(
            "A TLS router will terminate the TLS connection by default. However, the"
            " passthrough option can be specified to set whether the requests should be"
            ' forwarded "as is", keeping all data encrypted.'
        ),
    )
    options: str | None = Field(
        None,
        description=(
            "The options field enables fine-grained control of the TLS parameters. It"
            " refers to a TLS Options and will be applied only if a Host rule is"
            " defined."
        ),
    )
    cert_resolver: str | None = Field(
        None,
        alias="certResolver",
        description=(
            "If certResolver is defined, Traefik will try to generate certificates"
            " based on routers Host & HostSNI rules."
        ),
    )
    domains: list[Domain2] | None = Field(
        None,
        description=(
            "You can set SANs (alternative domains) for each main domain. Every domain"
            " must have A/AAAA records pointing to Traefik. Each domain & SAN will lead"
            " to a certificate request."
        ),
    )


class TcpRouter(BaseModel):
    """
    If both HTTP routers and TCP routers listen to the same entry points, the TCP
    routers will apply before the HTTP routers.  If no matching route is found for the
    TCP routers, then the HTTP routers will take over.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    entry_points: list[str] | None = Field(
        None,
        alias="entryPoints",
        description=(
            "If not specified, TCP routers will accept requests from all defined entry"
            " points. If you want to limit the router scope to a set of entry points,"
            " set the entry points option."
        ),
    )
    middlewares: list[str] | None = None
    rule: str = Field(
        ...,
        description=(
            "It is important to note that the Server Name Indication is an extension of"
            " the TLS protocol. Hence, only TLS routers will be able to specify a"
            " domain name with that rule. However, non-TLS routers will have to"
            " explicitly use that rule with * (every domain) to state that every"
            " non-TLS request will be handled by the router."
        ),
    )
    service: str = Field(
        ...,
        description=(
            "You must attach a TCP service per TCP router. Services are the target for"
            " the router. TCP routers can only target TCP services (not HTTP services)."
        ),
    )
    priority: int | None = Field(
        0,
        description=(
            "To avoid path overlap, routes are sorted, by default, in descending order"
            " using rules length. The priority is directly equal to the length of the"
            " rule, and so the longest length has the highest priority. A value of 0"
            " for the priority is ignored: priority = 0 means that the default rules"
            " length sorting is used."
        ),
        ge=0,
    )
    tls: Tls3 | None = Field(
        None,
        description=(
            "When a TLS section is specified, it instructs Traefik that the current"
            " router is dedicated to TLS requests only (and that the router should"
            " ignore non-TLS requests).\n\nBy default, a router with a TLS section will"
            " terminate the TLS connections, meaning that it will send decrypted data"
            " to the services."
        ),
    )


class Server1(BaseModel):
    address: str = Field(
        ..., description="The address option (IP:Port) point to a specific instance."
    )


class ProxyProtocol(BaseModel):
    version: int | None = None


class TcpLoadBalancerService(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    servers: list[Server1] = Field(
        ...,
        description="Servers declare a single instance of your program.",
        min_length=1,
    )
    termination_delay: float | None = Field(
        100,
        alias="terminationDelay",
        description=(
            "As a proxy between a client and a server, it can happen that either side"
            " (e.g. client side) decides to terminate its writing capability on the"
            " connection (i.e. issuance of a FIN packet). The proxy needs to propagate"
            " that intent to the other side, and so when that happens, it also does the"
            " same on its connection with the other side (e.g. backend"
            " side).\n\nHowever, if for some reason (bad implementation, or malicious"
            " intent) the other side does not eventually do the same as well, the"
            " connection would stay half-open, which would lock resources for however"
            " long.\n\nTo that end, as soon as the proxy enters this termination"
            " sequence, it sets a deadline on fully terminating the connections on both"
            " sides.\n\nThe termination delay controls that deadline. It is a duration"
            " in milliseconds, defaulting to 100. A negative value means an infinite"
            " deadline (i.e. the connection is never fully terminated by the proxy"
            " itself)."
        ),
    )
    proxy_protocol: ProxyProtocol | None = Field(None, alias="proxyProtocol")


class Service1(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    name: str
    weight: float


class TcpWeightedService(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    services: list[Service1] = Field(..., min_length=1)


class TcpServiceItem(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    load_balancer: TcpLoadBalancerService | None = Field(None, alias="loadBalancer")


class TcpServiceItem1(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    weighted: TcpWeightedService | None = None


TcpService = RootModel[TcpServiceItem | TcpServiceItem1]


class UdpRouter(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    entry_points: list[str] | None = Field(
        None,
        alias="entryPoints",
        description=(
            "If not specified, UDP routers will accept packets from all defined (UDP)"
            " entry points. If one wants to limit the router scope to a set of entry"
            " points, one should set the entry points option."
        ),
    )
    service: str = Field(
        ...,
        description=(
            "There must be one (and only one) UDP service referenced per UDP router."
            " Services are the target for the router."
        ),
    )


class Server2(BaseModel):
    address: str


class UdpLoadBalancerService(BaseModel):
    """In charge of balancing the requests between the servers of the same service."""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    servers: list[Server2] = Field(
        ...,
        description=(
            "The servers field defines all the servers that are part of this"
            " load-balancing group, i.e. each address (IP:Port) on which an instance of"
            " the service's program is deployed."
        ),
        min_length=1,
    )


class Service2(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    name: str
    weight: float


class UdpWeightedService(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    services: list[Service2] = Field(..., min_length=1)


class UdpServiceItem(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    load_balancer: UdpLoadBalancerService | None = Field(None, alias="loadBalancer")


class UdpServiceItem1(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    weighted: UdpWeightedService | None = None


UdpService = RootModel[UdpServiceItem | UdpServiceItem1]


class Http(BaseModel):
    routers: dict[str, HttpRouter] | None = None
    services: dict[str, HttpService] | None = None
    servers_transports: dict[str, ServersTransport] | None = Field(
        None, alias="serversTransports"
    )
    middlewares: dict[str, HttpMiddleware] | None = Field(
        None,
        description=(
            "Attached to the routers, pieces of middleware are a means of tweaking the"
            " requests before they are sent to your service (or before the answer from"
            " the services are sent to the clients).\n\nThere are several available"
            " middleware in Traefik, some can modify the request, the headers, some are"
            " in charge of redirections, some add authentication, and so on.\n\nPieces"
            " of middleware can be combined in chains to fit every scenario."
        ),
    )


class Tcp(BaseModel):
    routers: dict[str, TcpRouter] | None = None
    services: dict[str, TcpService] | None = Field(
        None,
        description=(
            "Each of the fields of the service section represents a kind of service."
            " Which means, that for each specified service, one of the fields, and only"
            " one, has to be enabled to define what kind of service is created."
            " Currently, the two available kinds are LoadBalancer, and Weighted."
        ),
    )


class Udp(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    routers: dict[str, UdpRouter] | None = Field(
        None,
        description=(
            "Similarly to TCP, as UDP is the transport layer, there is no concept of a"
            " request, so there is no notion of an URL path prefix to match an incoming"
            " UDP packet with. Furthermore, as there is no good TLS support at the"
            " moment for multiple hosts, there is no Host SNI notion to match against"
            " either. Therefore, there is no criterion that could be used as a rule to"
            ' match incoming packets in order to route them. So UDP "routers" at this'
            " time are pretty much only load-balancers in one form or another."
        ),
    )
    services: dict[str, UdpService] | None = Field(
        None,
        description=(
            "Each of the fields of the service section represents a kind of service."
            " Which means, that for each specified service, one of the fields, and only"
            " one, has to be enabled to define what kind of service is created."
            " Currently, the two available kinds are LoadBalancer, and Weighted."
        ),
    )


class TraefikFileConfig(BaseModel):
    """Traefik v2 Dynamic Configuration File Provider"""

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    http: Http | None = None
    tcp: Tcp | None = None
    udp: Udp | None = None
    tls: Tls | None = Field(
        None,
        description=(
            "Configures the TLS connection, TLS options, and certificate stores."
        ),
    )
