import abc
from collections.abc import Iterable
from pathlib import Path
from typing import Annotated, Self

from pydantic import Field, SerializeAsAny, field_validator, model_validator
from pydantic_settings import SettingsConfigDict

from bilder.components.hashicorp.models import (
    FlexibleBaseModel,
    HashicorpConfig,
    HashicorpProduct,
)
from bilder.lib.model_helpers import parse_simple_duration_string


class VaultAutoAuthMethodConfig(FlexibleBaseModel, abc.ABC):
    pass


class VaultAutoAuthSinkConfig(FlexibleBaseModel, abc.ABC):
    pass


class VaultAutoAuthFileSink(VaultAutoAuthSinkConfig):
    path: Path = Path("/etc/vault/vault_agent_token")
    mode: int | None = None


class VaultAutoAuthAppRole(VaultAutoAuthMethodConfig):
    role_id_file_path: Path
    secret_id_file_path: Path | None = None
    remove_secret_id_file_after_reading: bool = True
    secret_id_response_wrapping_path: Path | None = None


class VaultAutoAuthAWS(VaultAutoAuthMethodConfig):
    # The type of authentication; must be ec2 or iam.
    type: str = "iam"
    # The role to authenticate against on Vault.
    role: str
    # In seconds, how frequently the Vault agent should check for new credentials if
    # using the iam type.
    credential_poll_interval: int | None = None
    access_key: str | None = None
    secret_key: str | None = None
    region: str = "us-east-1"
    session_token: str | None = None
    header_value: str | None = None


class VaultAutoAuthMethod(FlexibleBaseModel):
    type: str
    mount_path: str | None = None
    namespace: str | None = None
    wrap_ttl: str | int | None = None
    config: SerializeAsAny[VaultAutoAuthMethodConfig]


class VaultAutoAuthSink(FlexibleBaseModel):
    type: str
    wrap_ttl: str | int | None = None
    dh_type: str | None = None
    dh_path: Path | None = None
    derive_key: bool = False
    aad: str | None = None
    aad_env_var: str | None = None
    config: list[SerializeAsAny[VaultAutoAuthSinkConfig]]


class VaultAgentCache(FlexibleBaseModel):
    use_auto_auth_token: str | bool = True


class VaultAwsKmsSealConfig(FlexibleBaseModel):
    region: str | None = "us-east-1"
    access_key: str | None = None
    secret_key: str | None = None
    kms_key_id: str | None = None
    endpoint: str | None = None
    session_token: str | None = None


class VaultSealConfig(FlexibleBaseModel):
    awskms: VaultAwsKmsSealConfig | None = None


class VaultTelemetryConfig(FlexibleBaseModel):
    usage_gauge_period: str | None = None
    maximum_gauge_cardinality: int | None = None
    disable_hostname: bool = False
    enable_hostname_label: bool = False


class ConsulStorageBackend(FlexibleBaseModel):
    address: str | None = None
    check_timeout: str | None = "5s"
    consistency_mode: str | None = "default"
    disable_registration: bool = False
    max_parallel: str | None = None
    path: str | None = "vault/"
    scheme: str | None = "http"
    service: str | None = "vault"
    service_tags: str | None = None
    token: str | None = None
    session_ttl: str | None = "15s"
    tls_ca_file: Path | None = None
    tls_cert_file: Path | None = None
    tls_key_file: Path | None = None
    tls_min_version: str | None = "tls12"


class VaultRetryJoin(FlexibleBaseModel):
    leader_api_addr: str | None = None
    auto_join: str | None = None
    auto_join_scheme: str | None = None
    auto_join_port: int | None = None
    leader_tls_servername: str | None = None
    leader_ca_cert_file: Path | None = None
    leader_client_cert_file: Path | None = None
    leader_client_key_file: Path | None = None
    leader_ca_cert: str | None = None
    leader_client_cert: str | None = None
    leader_client_key: str | None = None


class IntegratedRaftStorageBackend(FlexibleBaseModel):
    path: Path = Path("/var/lib/vault/raft/")
    performance_multiplier: Annotated[int, Field(ge=0, le=10)] | None = None
    # The node_id is an optional parameter that will receive an autogenerated UUID if
    # not set.
    # https://github.com/hashicorp/vault/blob/master/physical/raft/raft.go#L289-L329
    node_id: str | None = None
    trailing_logs: int | None = None
    snapshot_threshold: int | None = None
    retry_join: list[VaultRetryJoin] | None = None
    max_entry_size: int | None = None
    autopilot_reconcile_interval: str | None = None


class VaultStorageBackend(FlexibleBaseModel):
    """Container class for holding named references to storage implementations.

    In order to add support for configuring an additional storage backend, the name of
    the backend as defined by Vault is set as the attribute name, and the type of the
    attribute is Optional[<NameOfStorageClass>].  This allows us to pass an instance of
    that class object to the associated attribute so that the rendered JSON is of the
    form

    {"storage": {"raft": {"path": "/data/storage/path"}}}
    """

    consul: ConsulStorageBackend | None = None
    raft: IntegratedRaftStorageBackend | None = None


class VaultAutoAuthConfig(FlexibleBaseModel):
    method: VaultAutoAuthMethod
    sink: list[VaultAutoAuthSink] | None = None


class VaultConnectionConfig(FlexibleBaseModel):
    address: str
    ca_cert: Path | None = None
    ca_path: Path | None = None
    client_cert: Path | None = None
    client_key: Path | None = None
    tls_skip_verify: bool = False
    tls_server_name: str | None = None


class VaultTemplate(FlexibleBaseModel):
    source: Path | None = None
    contents: str | None = None
    destination: Path
    create_dest_dirs: bool = True
    command: str | None = None


class VaultTelemetryListener(FlexibleBaseModel):
    unauthenticated_metrics_access: bool = False


class VaultTCPListener(FlexibleBaseModel):
    address: str | None = None
    cluster_address: str | None = None
    http_idle_timeout: str | None = None
    http_read_header_timeout: str | None = None
    http_read_timeout: str | None = None
    http_write_timeout: str | None = None
    max_request_size: int | None = None
    max_request_duration: str | None = None
    tls_disable: bool | None = None
    tls_cert_file: Path | None = None
    tls_key_file: Path | None = None
    tls_min_version: str | None = None
    telemetry: VaultTelemetryListener | None = None


class VaultListener(FlexibleBaseModel):
    tcp: VaultTCPListener | None = None


class ConsulServiceRegistration(FlexibleBaseModel):
    # address of Consul agent to communicate with
    address: str | None = None
    check_timeout: str | None = None
    disable_registration: str = "false"
    scheme: str | None = "http"
    service: str | None = "vault"
    service_tags: list[str] | None = None
    service_address: str | None = ""
    # Consul ACL token to authorize setting the service definition
    token: str | None = None
    tls_ca_file: Path | None = None
    tls_cert_file: Path | None = None
    tls_key_file: Path | None = None
    tls_min_version: str | None = None
    tls_skip_verify: bool | None = None


class VaultServiceRegistration(FlexibleBaseModel):
    consul: ConsulServiceRegistration | None = None


class VaultAgentConfig(HashicorpConfig):
    model_config = SettingsConfigDict(env_prefix="vault_agent_")
    vault: VaultConnectionConfig | None = None
    auto_auth: VaultAutoAuthConfig | None = None
    cache: VaultAgentCache | None = VaultAgentCache()
    pid_file: Path | None = None
    exit_after_auth: bool = False
    template: list[VaultTemplate] | None = None
    listener: list[VaultListener] | None = None
    restart_period: str | None = None
    restart_jitter: str | None = None

    @model_validator(mode="after")
    def validate_restart_settings(self) -> Self:
        if self.restart_period is not None and self.restart_jitter is None:
            msg = "If restart_period is set then a restart_jitter must be supplied."
            raise ValueError(msg)
        return self

    @field_validator("restart_period")
    @classmethod
    def validate_restart_period(cls, restart_period) -> str:
        if restart_period and not parse_simple_duration_string(restart_period):
            msg = f"Invalid restart_period duration: {restart_period}"
            raise ValueError(msg)
        return restart_period

    @field_validator("restart_jitter")
    @classmethod
    def validate_restart_jitter(cls, restart_jitter) -> str:
        if restart_jitter and not parse_simple_duration_string(restart_jitter):
            msg = f"Invalid restart_jitter duration: {restart_jitter}"
            raise ValueError(msg)
        return restart_jitter


class VaultServerConfig(HashicorpConfig):
    model_config = SettingsConfigDict(env_prefix="vault_")
    api_addr: str | None = None
    cache_size: str | None = None
    cluster_addr: str | None = None
    cluster_name: str | None = None
    default_lease_ttl: str | None = None
    default_max_request_duration: str | None = None
    disable_cache: bool = False
    disable_clustering: bool = False
    disable_mlock: bool = False
    ha_storage: list[VaultStorageBackend] | None = None
    listener: list[VaultListener] | None = None
    log_format: str = "json"
    log_level: str = "Warn"
    max_lease_ttl: str | None = None
    plugin_directory: Path | None = None
    seal: list[VaultSealConfig] | None = None
    service_registration: VaultServiceRegistration | None = None
    # Set storage as optional to allow for splitting into a separate config file
    storage: VaultStorageBackend | None = None
    telemetry: VaultTelemetryConfig | None = None
    ui: bool | None = False


class Vault(HashicorpProduct):
    _name: str = "vault"
    version: str = "1.8.0"
    configuration: dict[Path, HashicorpConfig] = {  # noqa: RUF012
        Path("vault.json"): VaultAgentConfig()
    }
    configuration_directory: Path = Path("/etc/vault/")
    data_directory: Path = Path("/var/lib/vault/")

    @field_validator("configuration")
    @classmethod
    def validate_consistent_config_types(cls, configuration):
        type_set = {type(config_obj) for config_obj in configuration.values()}
        if len(type_set) > 1:
            msg = "There are server and agent configuration objects present"
            raise ValueError(msg)
        return configuration

    def operating_mode(self) -> str:
        mode_map = {VaultAgentConfig: "agent", VaultServerConfig: "server"}
        return mode_map[{type(conf) for conf in self.configuration.values()}.pop()]

    @property
    def systemd_template_context(self):
        context_dict = {
            "mode": self.operating_mode(),
            "configuration_directory": self.configuration_directory,
        }
        if self.operating_mode() == "agent":
            conf_path = next(iter(self.configuration.keys()))
            context_dict["configuration_file"] = conf_path
            context_dict["restart_period"] = self.configuration[
                conf_path
            ].restart_period
            context_dict["restart_jitter"] = self.configuration[
                conf_path
            ].restart_jitter
        return context_dict

    def render_configuration_files(self) -> Iterable[tuple[Path, str]]:
        for fpath, config in self.configuration.items():
            yield (
                self.configuration_directory.joinpath(fpath),
                config.model_dump_json(
                    exclude_none=True,
                    exclude={"restart_period", "restart_jitter"},
                    indent=2,
                ),
            )
